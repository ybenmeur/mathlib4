import Mathlib.Algebra.Category.ModuleCat.Basic
import Mathlib.Algebra.Category.ModuleCat.Monoidal.Basic
import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.CategoryTheory.Monoidal.NaturalTransformation
import Mathlib.RepresentationTheory.FDRep

/-!
# Tannaka duality for finite groups

Given a field `k` and a finite group `G`, Tannaka duality expresses the fact that one can recover
`G` from the monoidal category `FDRep k G` of finite dimensional representations of `G` over `k`.

More specifically, we consider the monoidal forgetful functor `F k G : FDRep k G ‚•§ ModuleCat k`
to the category of vector spaces over `k`, and `Aut (F k G)` its group of automorphisms, i.e. the
group of monoidal natural isomorphisms `(F k G) ‚üπ (F k G)`. We further construct the group
homomorphism `T : G ‚Üí* Aut (F k G)` defined by `T g ‚ü®V, œÅ‚ü© := œÅ g`.

The theorem `tannaka_duality` states that `T` is an isomorphism.

The proof revolves around one particular representation `œÑ·µ£` on `G ‚Üí k` induced by multiplication
on the right in `G`.

## Mathematical notations

- `F` : monoidalforgetful functor `FDRep k G ‚•§ Vect k`
- `T` : the morphism `G ‚Üí* Aut (F k G)` given by `T g ‚ü®V, œÅ‚ü© = œÅ g` that is shown to be bijective
- `e s` : indicator function of `s` on `G ‚Üí k` (i.e. `e s t = 1 ‚Üî s = t`)
  (abbreviation for `Pi.single s (1 : k)` in mathlib)
- `œÑ·µ£` : representation on `G ‚Üí k` given by `œÑ·µ£ s f t = f (t * s)` (multiplication on the right)
- `Œ±` : map sending a natural transformation `Œ∑ : F ‚üπ F` to its `œÑ·µ£` component

## Reference

<https://math.leidenuniv.nl/scripties/1bachCommelin.pdf>
-/

noncomputable section

open CategoryTheory MonoidalCategory

universe u

variable (k G : Type u)

section forget

variable [CommRing k] [Monoid G] (X : FDRep k G)

instance : (forget‚ÇÇ (FDRep k G) (FGModuleCat k)).Monoidal := by
  change (Action.forget _ _).Monoidal
  infer_instance

/-- The monoidal forgetful functor from `FDRep k G` to `FGModuleCat k` -/
def F := LaxMonoidalFunctor.of (forget‚ÇÇ (FDRep k G) (FGModuleCat k))

lemma F_Œº {X Y : FDRep k G} :
  Functor.LaxMonoidal.Œº (F k G).toFunctor X Y = ùüô _ := rfl

end forget

variable [Field k]

section T

variable {k G} [Group G] (Œ∑ : Aut (F k G))

@[simp]
theorem œÅ_inv_self_apply {A : FDRep k G} (g : G) (x : A) :
    A.œÅ g‚Åª¬π (A.œÅ g x) = x :=
  show (A.œÅ g‚Åª¬π * A.œÅ g) x = x by rw [‚Üê map_mul, inv_mul_cancel, map_one, LinearMap.one_apply]

@[simp]
theorem œÅ_self_inv_apply {A : FDRep k G} (g : G) (x : A) :
    A.œÅ g (A.œÅ g‚Åª¬π x) = x :=
  show (A.œÅ g * A.œÅ g‚Åª¬π) x = x by rw [‚Üê map_mul, mul_inv_cancel, map_one, LinearMap.one_apply]

/-- Definition of `T g : Aut (F k G)` by its components -/
@[simps]
def T_app (g : G) (X : FDRep k G) : X.V ‚âÖ X.V where
  hom := ModuleCat.ofHom (X.œÅ g)
  inv := ModuleCat.ofHom (X.œÅ g‚Åª¬π)
  hom_inv_id := by
    ext x
    exact œÅ_inv_self_apply g x
  inv_hom_id := by
    ext x
    exact œÅ_self_inv_apply g x

/-- The function defining `T` -/
def T_fun : G ‚Üí Aut (F k G) := by
  intro g
  apply LaxMonoidalFunctor.isoOfComponents (T_app g) ?_ rfl (by intros; rfl)
  intro _ _ f
  exact (f.comm g).symm

lemma T_apply (g : G) (X : FDRep k G) :
    ((T_fun g).hom.hom.app X).hom = X.œÅ g := rfl

variable (k G) in
/-- The group homomorphism `G ‚Üí* Aut (F k G)` involved in the main theorem -/
def T : G ‚Üí* Aut (F k G) where
  toFun := T_fun
  map_one' := by
    ext
    simp only [T_apply, map_one]
    exact rfl
  map_mul' := by
    intros
    ext
    simp only [T_apply, map_mul]
    exact rfl

end T

section Indicator

variable {k} {G : Type u} [DecidableEq G]

/-- Indicator function of `s : G` -/
abbrev e (s : G) : G ‚Üí k := Pi.single s (1 : k)

lemma e_eq_same (s : G) : e s s = (1 : k) := Pi.single_eq_same s 1

lemma e_eq_of_ne {s t : G} (h : s ‚â† t) : e s t = (0 : k) := Pi.single_eq_of_ne' h 1

lemma eq_of_e_eq_one {s t : G} (h : e s t = (1 : k)) : s = t := by
  by_contra
  simp_all only [ne_eq, not_false_eq_true, Pi.single_eq_of_ne', zero_ne_one]

lemma mul_e (s : G) (f : G ‚Üí k) : (e s) * f = f s ‚Ä¢ (e s) := by
    ext t
    simp only [Pi.mul_apply, Pi.smul_apply, smul_eq_mul]
    by_cases h : s = t
    ¬∑ rw [h]
      exact mul_comm _ _
    ¬∑ rwa [e_eq_of_ne, zero_mul, mul_zero]

lemma e_mul_self (s : G) : (e s) * (e s) = ((e s) : G ‚Üí k) := by
  ext
  rw [mul_e, e_eq_same, one_smul]

lemma e_eq_iff (s t u v : G) : (e s t = (e u v : k)) ‚Üî (s = t ‚Üî u = v) := by
  have e_eq {s t u v : G} (h : e s t = (e u v : k)) : s = t ‚Üí u = v := by
    intro
    simp_all only [Pi.single_eq_same]
    exact eq_of_e_eq_one h.symm
  constructor
  ¬∑ intro h
    exact ‚ü®e_eq h, e_eq h.symm‚ü©
  ¬∑ intro h
    by_cases h' : s = t
    ¬∑ rw [h', e_eq_same, h.mp h', e_eq_same]
    ¬∑ rw [e_eq_of_ne h', e_eq_of_ne (h' ‚àò h.mpr)]

lemma e_right_mul [Group G] (s t u : G) :
    e t (u * s) = (e (t * s‚Åª¬π) u : k) := by
  simp only [e_eq_iff]
  exact mul_inv_eq_iff_eq_mul.symm

end Indicator

variable {k G} [Group G]

section fdRepœÑ·µ£

/-- The representation on `G ‚Üí k` induced by multiplication on the right in `G` -/
def œÑ·µ£ : Representation k G (G ‚Üí k) where
  toFun s := {
    toFun f := fun t ‚Ü¶ f (t * s)
    map_add' _ _ := rfl
    map_smul' _ _ := rfl
  }
  map_one' := by
    ext
    simp
  map_mul' _ _ := by
    ext
    simp [mul_assoc]

lemma œÑ·µ£_apply (s : G) (f : G ‚Üí k) (t : G) : œÑ·µ£ s f t = f (t * s) := rfl

/-- The representation on `G ‚Üí k` induced by multiplication on the left in `G` -/
def œÑ‚Çó : Representation k G (G ‚Üí k) where
  toFun s := {
    toFun f := fun t ‚Ü¶ f (s‚Åª¬π * t)
    map_add' _ _ := rfl
    map_smul' _ _ := rfl
  }
  map_one' := by
    ext
    simp
  map_mul' _ _ := by
    ext
    simp [mul_assoc]

lemma œÑ‚Çó_apply (s : G) (f : G ‚Üí k) (t : G) : œÑ‚Çó s f t = f (s‚Åª¬π * t) := rfl

variable [Fintype G]

variable (k G) in
/-- The representation `‚ü®G ‚Üí k, œÑ·µ£‚ü©` induced by multiplication on
the right in `G` as a `FDRep k G` -/
def fdRepœÑ·µ£ : FDRep k G := FDRep.of œÑ·µ£

variable (k G) in
/-- The representation `‚ü®G ‚Üí k, œÑ‚Çó‚ü©` induced by multiplication on
  the left in `G` as a `FDRep k G` -/
def fdRepœÑ‚Çó : FDRep k G := FDRep.of œÑ‚Çó

/-- Map sending `Œ∑ : Aut (F k G)` to its component at `fdRepœÑ·µ£ k G` as a linear map -/
def Œ± (Œ∑ : Aut (F k G)) : (G ‚Üí k) ‚Üí‚Çó[k] (G ‚Üí k) := (Œ∑.hom.hom.app (fdRepœÑ·µ£ k G)).hom

end fdRepœÑ·µ£

variable [DecidableEq G] [Fintype G]

section lemma4

-- *lemma 4.4*
lemma T_inj : Function.Injective (T k G) := by
  rw [injective_iff_map_eq_one]
  intro s h
  apply_fun Œ± at h
  replace h : (e 1) (1 * s) = e 1 1 := congrFun (congrFun (congrArg DFunLike.coe h) (e 1)) 1
  rw [e_eq_same, one_mul] at h
  exact (eq_of_e_eq_one h).symm

end lemma4

section lemma5

-- *lemma 4.5*
/-- An algebra morphism `œÜ : (G ‚Üí k) ‚Üí‚Çê[k] k` is an evaluation map. -/
lemma eval_of_alghom {G : Type u} [DecidableEq G] [Fintype G] (œÜ : (G ‚Üí k) ‚Üí‚Çê[k] k) :
    ‚àÉ (s : G), œÜ = Pi.evalAlgHom _ _ s := by
  have h1 := map_one œÜ
  obtain ‚ü®s, hs‚ü© : ‚àÉ (s : G), œÜ (e s) ‚â† 0 := by
    rw [‚Üê Finset.univ_sum_single (1 : G ‚Üí k)] at h1
    by_contra
    simp_all
  have h2 : œÜ (1 - (e s)) = 0 := by
    apply eq_zero_of_ne_zero_of_mul_right_eq_zero hs
    rw [‚Üê map_mul]
    convert map_zero œÜ
    rw [mul_sub_right_distrib, one_mul, e_mul_self, sub_self]
  have h3 : œÜ (e s) = 1 := by
    rw [map_sub, h1, sub_eq_zero] at h2
    exact h2.symm
  use s
  ext f
  conv_lhs => rw [‚Üê one_mul (œÜ f), ‚Üê h3, ‚Üê map_mul]
  rw [Pi.evalAlgHom_apply, mul_e, map_smul, smul_eq_mul, h3, mul_one]

end lemma5

section lemma6

/-- The `FDRep k G` morphism induced by multiplication on `G ‚Üí k`. -/
def Œº : fdRepœÑ·µ£ k G ‚äó fdRepœÑ·µ£ k G ‚ü∂ fdRepœÑ·µ£ k G where
  hom := ModuleCat.ofHom (LinearMap.mul' k (G ‚Üí k))
  comm := by
    intro (_ : G)
    ext (u : TensorProduct k (G ‚Üí k) (G ‚Üí k))
    refine TensorProduct.induction_on u rfl (fun _ _ ‚Ü¶ rfl) ?_
    intro _ _ hx hy
    simp only [map_add, hx, hy]

/-- For `Œ∑ : Aut (F k G)`, `Œ± Œ∑` preserves multiplication -/
def map_mul_Œ± (Œ∑ : Aut (F k G)) :
    ‚àÄ (x y : G ‚Üí k), (Œ± Œ∑) (x * y) = ((Œ± Œ∑) x) * ((Œ± Œ∑) y) := by
  intro f g
  have a := Œ∑.hom.hom.naturality Œº
  have b := Œ∑.hom.isMonoidal.tensor
  simp only [F_Œº, Category.id_comp, Category.comp_id] at b
  rw [b] at a
  apply_fun ModuleCat.Hom.hom at a
  exact (congrFun (congrArg DFunLike.coe a) (f ‚äó‚Çú[k] g))

-- *lemma 4.6*
/-- `Œ± Œ∑` is an algebra morphism, for `Œ∑ : Aut (F k G)` -/
def algHomOfŒ± (Œ∑ : Aut (F k G)) : ((G ‚Üí k)) ‚Üí‚Çê[k] ((G ‚Üí k)) := by
  refine AlgHom.ofLinearMap (Œ± Œ∑) ?_ (map_mul_Œ± Œ∑)
  let Œ±_inv : (G ‚Üí k) ‚Üí (G ‚Üí k) := (Œ∑.inv.hom.app (fdRepœÑ·µ£ k G)).hom
  have := Œ∑.inv_hom_id
  apply_fun LaxMonoidalFunctor.Hom.hom at this
  apply_fun NatTrans.app at this
  replace := congrFun this (fdRepœÑ·µ£ k G)
  apply_fun ModuleCat.Hom.hom at this
  have : (Œ± Œ∑) (Œ±_inv 1) = (1 : G ‚Üí k) := congrFun (congrArg DFunLike.coe this) (1 : G ‚Üí k)
  have h := this
  rwa [‚Üê one_mul (Œ±_inv 1), map_mul_Œ±, h, mul_one] at this

end lemma6

section lemma7

/-- `œÑ‚Çó` commutes with `œÑ·µ£`, so it is a representation morphism of `fdRepœÑ·µ£` -/
def œÑ‚ÇófdRepHom (s : G) : (fdRepœÑ·µ£ k G) ‚ü∂ (fdRepœÑ·µ£ k G) where
  hom := ModuleCat.ofHom (œÑ‚Çó s)
  comm := by
    intro (t : G)
    ext (f : G ‚Üí k)
    simp only [ModuleCat.hom_comp, ModuleCat.hom_ofHom, Rep.œÅ_hom, LinearMap.coe_comp,
      Function.comp_apply]
    rw [funext_iff]
    intro u
    change (œÑ‚Çó s) ((œÑ·µ£ t) f) u = (œÑ·µ£ t) ((œÑ‚Çó s) f) u
    simp only [œÑ‚Çó_apply, œÑ·µ£_apply, mul_assoc]

-- *lemma 4.7*
lemma image_Œ±_in_image_œÑ·µ£ (Œ∑ : Aut (F k G)) : ‚àÉ (s : G), Œ± Œ∑ = œÑ·µ£ s := by
  have hnat (t : G) := Œ∑.hom.hom.naturality (œÑ‚ÇófdRepHom t)
  let Œ±_hom := algHomOfŒ± Œ∑
  obtain ‚ü®s, hs‚ü© := eval_of_alghom ((Pi.evalAlgHom _ _ (1 : G)).comp Œ±_hom)
  use s
  have (u t : G) : Œ±_hom (e u) t = e (t‚Åª¬π * u) s := by
    specialize hnat t‚Åª¬π
    apply_fun ModuleCat.Hom.hom at hnat
    calc
      _ = Œ±_hom (e u) ((t‚Åª¬π)‚Åª¬π * 1) := by
        rw [mul_one, inv_inv]
      _ = œÑ‚Çó t‚Åª¬π (Œ±_hom (e u)) 1 := rfl
      _ = Œ±_hom (œÑ‚Çó t‚Åª¬π (e u)) 1 :=
        congrFun (congrFun (congrArg DFunLike.coe hnat) (e u)).symm 1
      _ = (Pi.evalAlgHom _ _ 1).comp Œ±_hom (œÑ‚Çó t‚Åª¬π (e u)) := rfl
      _ = Pi.evalAlgHom _ _ s (œÑ‚Çó t‚Åª¬π (e u)) :=
        congrFun (congrArg DFunLike.coe hs) _
      _ = _ := by
        rw [Pi.evalAlgHom_apply, œÑ‚Çó_apply, e_eq_iff]
        exact eq_inv_mul_iff_mul_eq
  apply Basis.ext (Pi.basisFun k G)
  intro u
  simp only [Pi.basisFun_apply, funext_iff]
  intro t
  change Œ±_hom _ _ = _
  rw [œÑ·µ£_apply, this, e_eq_iff]
  exact inv_mul_eq_iff_eq_mul

end lemma7

section lemma8

/-- Auxiliary map for the proof of `Œ±_inj` -/
def œÜ {X : FDRep k G} (v : X) : (G ‚Üí k) ‚Üí‚Çó[k] X where
  toFun := fun f ‚Ü¶ ‚àë s : G, (f s) ‚Ä¢ (X.œÅ s‚Åª¬π v)
  map_add' := by
    intros
    simp only [Pi.add_apply, add_smul]
    exact Finset.sum_add_distrib
  map_smul' := by
    intros
    simp only [Pi.smul_apply, smul_eq_mul, RingHom.id_apply, Finset.smul_sum, smul_smul]

lemma œÜ_apply {k G : Type u} [Field k] [Group G] [Fintype G] {X : FDRep k G} (v : X) (f : G ‚Üí k) :
  (œÜ v) f = ‚àë s : G, f s ‚Ä¢ (X.œÅ s‚Åª¬π) v := rfl

lemma œÜ_e_one_eq_id {X : FDRep k G} (v : X) : (œÜ v) (e 1) = v := by
  rw [œÜ_apply]
  let a (s : G) : X.V := (e (1 : G) s : k) ‚Ä¢ (X.œÅ s‚Åª¬π) v
  calc
    _ = (‚àë s ‚àà {1}·∂ú, a s) + a 1 :=
      Fintype.sum_eq_sum_compl_add _ _
    _ = a 1 := by
      apply add_left_eq_self.mpr
      apply Finset.sum_eq_zero
      simp_all only [Finset.mem_compl, Finset.mem_singleton, ne_eq, not_false_eq_true,
        Pi.single_eq_of_ne, zero_smul, implies_true, a]
    _ = _ := by
      simp only [Pi.single_eq_same, inv_one, map_one, LinearMap.one_apply, one_smul, a]

/-- Auxiliary representation morphism for the proof of `Œ±_inj` -/
@[simps]
def œÜRepMor (X : FDRep k G) (v : X) : (fdRepœÑ·µ£ k G) ‚ü∂ X where
  hom := ModuleCat.ofHom (œÜ v)
  comm := by
    intro (t : G)
    ext (f : G ‚Üí k)
    change (œÜ v) (œÑ·µ£ t f) = X.œÅ t (œÜ v f)
    simp only [œÜ_apply, map_sum]
    set œÜ_term := fun (X : FDRep k G) (f : G ‚Üí k) (v s) ‚Ü¶ (f s) ‚Ä¢ (X.œÅ s‚Åª¬π v)
    have := Finset.sum_map Finset.univ (mulRightEmbedding t‚Åª¬π) (œÜ_term X (œÑ·µ£ t f) v)
    simp only [œÜ_term, Finset.univ_map_embedding] at this
    rw [this]
    apply Finset.sum_congr rfl
    simp [œÑ·µ£_apply, mul_assoc]

-- *lemma 4.8*
/-- If `Œ∑‚ÇÅ Œ∑‚ÇÇ : Aut (F k G)` agree on `fdRepœÑ·µ£` then they are equal -/
lemma Œ±_inj (Œ∑‚ÇÅ Œ∑‚ÇÇ : Aut (F k G))
    (h : Œ∑‚ÇÅ.hom.hom.app (fdRepœÑ·µ£ k G) = Œ∑‚ÇÇ.hom.hom.app (fdRepœÑ·µ£ k G)) : Œ∑‚ÇÅ = Œ∑‚ÇÇ := by
  ext X v
  have h1 := congrArg ModuleCat.Hom.hom (Œ∑‚ÇÅ.hom.hom.naturality (œÜRepMor X v))
  have h2 := Œ∑‚ÇÇ.hom.hom.naturality (œÜRepMor X v)
  rw [h, ‚Üê h2] at h1
  apply_fun (¬∑ (e 1)) at h1
  change (Œ∑‚ÇÅ.hom.hom.app X).hom ((œÜ v) (e 1)) = (Œ∑‚ÇÇ.hom.hom.app X).hom ((œÜ v) (e 1)) at h1
  simp [œÜ_e_one_eq_id] at h1
  exact h1

end lemma8

section prop11

-- *proposition 4.11*
lemma T_surj : Function.Surjective (T k G) := by
  intro Œ∑
  obtain ‚ü®s, h‚ü© := image_Œ±_in_image_œÑ·µ£ Œ∑
  use s
  apply Œ±_inj
  apply ModuleCat.hom_ext
  exact h.symm

end prop11

section thm

-- *theorem 4.3*
theorem tannaka_duality : Function.Bijective (T k G) :=
  ‚ü®T_inj, T_surj‚ü©

example : G ‚âÉ* Aut (F k G) :=
  MulEquiv.ofBijective (T k G) tannaka_duality

end thm
